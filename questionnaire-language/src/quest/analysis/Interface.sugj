package quest.analysis;

import quest.lang.Syntax;
import quest.analysis.Typing;

public sugar Interface {
    signature
      constructors
        IQuestionaire : Modifiers * String * Body -> InterfaceComponent
        IQuestion : String * String * String -> InterfaceComponent
        IQuestGroup : String * Body -> InterfaceComponent
        IValue : String * QuestId -> InterfaceComponent

        ConditionalQuest : QuestExpr * Question * Question -> Question
    rules
      extract-interface : Questionnaire(mods, Id(idj), body) -> ("quest", ifc)
        where ifc := IQuestionaire(mods, idj, <extract-interface> body)

      extract-interface : QuestGroup(QuestId(idj), body) -> IQuestGroup(idj, <extract-interface> body)

      extract-interface : q@Question(_, QuestId(name), QuestText(text)) -> IQuestion(type, name, text)
        where type := <retrieve-type> q

      extract-interface: q@LocalQuest(Question(_, QuestId(name), QuestText(text))) -> IQuestion(type, name, text)
        where type := <retrieve-type> q

      extract-interface : v@DerivedValue(_, QuestId(name), exp) -> IValue(type, name)
        where type := <retrieve-type> exp
      extract-interface : v@DerivedValue(QuestType(type), QuestId(name), exp) -> IValue(type, name)
      
      extract-interface : ConditionalQuest(_, _, _) -> []
      extract-interface: Some(x) -> <extract-interface> x
      extract-interface: None() -> None()
      extract-interface: QuestRef(_) -> []
      extract-interface: ExternalRef(_, _) -> []

      extract-interface: QNil -> []
      extract-interface: QCons(x, xs) -> <conc> (<ensure-list(extract-interface)> x, <extract-interface> xs)

      ensure-list(s) = s < (is-list <+ ![<id>]) + ![]
}
