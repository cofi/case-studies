package quest.analysis;

import quest.lang.Syntax;
import quest.analysis.Typing;

public sugar Interface {
    signature
      constructors
        IQuestionaire : Modifiers * QuestId * Body -> InterfaceComponent
        IQuestion : QuestType * QuestId -> InterfaceComponent
        IQuestGroup : QuestId * Body -> InterfaceComponent
        IValue : QuestType * QuestId -> InterfaceComponent

        ConditionalQuest : QuestExpr * Question * Question -> Question
    rules
      extract-interface : Questionnaire(mods, idj, body) -> ("quest", ifc)
        where ifc := IQuestionaire(mods, idj, <extract-interface> body)

      extract-interface : QuestGroup(idj, body) -> IQuestGroup(idj, <extract-interface> body)

      extract-interface : q@Question(_, name, _) -> IQuestion(type, name)
        where type := <retrieve-type> q
      extract-interface : Question(type, name, _) -> IQuestion(type, name)

      extract-interface: LocalQuest(exp) -> <extract-interface> exp

      extract-interface : v@DerivedValue(_, name, _) -> IValue(type, name)
        where type := <retrieve-type> v
      extract-interface : DerivedValue(type, name, _) -> IValue(type, name)

      extract-interface : ConditionalQuest(_, _, _) -> []
      extract-interface: Some(x) -> <extract-interface> x
      extract-interface: None() -> None()
      extract-interface: QuestRef(_) -> []

      extract-interface: QNil -> []
      extract-interface: QCons(x, xs) -> <conc> (<ensure-list(extract-interface)> x, <extract-interface> xs)

      ensure-list(s) = s < (is-list <+ ![<id>]) + ![]
}
